mod error;

use byteorder::{ReadBytesExt, WriteBytesExt, LE};
use std::io::{Read, Write};

use serde::{Deserialize, Serialize};

type TResult<T> = Result<T, crate::error::Error>;

trait Readable<R> {
    fn read(reader: &mut R) -> TResult<Self>
    where
        Self: Sized;
}
trait Writable<W> {
    fn write(&self, writer: &mut W) -> TResult<()>;
}

fn read_optional_uuid<R: Read>(reader: &mut R) -> TResult<Option<uuid::Uuid>> {
    Ok(if reader.read_u8()? > 0 {
        Some(uuid::Uuid::read(reader)?)
    } else {
        None
    })
}
fn write_optional_uuid<W: Write>(writer: &mut W, id: Option<uuid::Uuid>) -> TResult<()> {
    if let Some(id) = id {
        writer.write_u8(1)?;
        id.write(writer)?;
    } else {
        writer.write_u8(0)?;
    }
    Ok(())
}

fn read_string<R: Read>(reader: &mut R) -> TResult<String> {
    let mut chars = vec![0; reader.read_u32::<LE>()? as usize];
    reader.read_exact(&mut chars)?;
    let length = chars.iter().position(|&c| c == 0).unwrap_or(chars.len());
    Ok(String::from_utf8_lossy(&chars[..length]).into_owned())
}
fn write_string<W: Write>(writer: &mut W, string: &str) -> TResult<()> {
    writer.write_u32::<LE>(string.as_bytes().len() as u32 + 1)?;
    writer.write_all(string.as_bytes())?;
    writer.write_u8(0)?;
    Ok(())
}
fn read_properties_until_none<R: Read>(reader: &mut R) -> TResult<Vec<Property>> {
    let mut properties = vec![];
    while let Some(prop) = Property::read(reader)? {
        properties.push(prop);
    }
    Ok(properties)
}
fn write_properties_none_terminated<W: Write>(
    writer: &mut W,
    properties: &Vec<Property>,
) -> TResult<()> {
    for p in properties {
        p.write(writer)?;
    }
    write_string(writer, "None")?;
    Ok(())
}
fn read_array<T, R: Read>(
    length: u32,
    reader: &mut R,
    f: fn(&mut R) -> TResult<T>,
) -> TResult<Vec<T>> {
    (0..length).map(|_| f(reader)).collect()
}

impl<R: Read> Readable<R> for uuid::Uuid {
    fn read(reader: &mut R) -> TResult<uuid::Uuid> {
        let mut buf = [0; 16];
        reader.read_exact(&mut buf)?;
        Ok(uuid::Uuid::from_bytes(buf))
    }
}
impl<W: Write> Writable<W> for uuid::Uuid {
    fn write(&self, writer: &mut W) -> TResult<()> {
        writer.write_all(self.as_bytes())?;
        Ok(())
    }
}

#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum PropertyType {
    Guid,
    DateTime,
    Box,
    Vector2D,
    Vector,
    Quat,
    Rotator,
    LinearColor,
    IntProperty,
    UInt32Property,
    FloatProperty,
    BoolProperty,
    ByteProperty,
    StructProperty,
    ArrayProperty,
    ObjectProperty,
    StrProperty,
    NameProperty,
    TextProperty,
    MulticastInlineDelegateProperty,
    SetProperty,
    MapProperty,
    Other(String),
}
impl PropertyType {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        let t = read_string(reader)?;
        match t.as_str() {
            "Guid" => Ok(PropertyType::Guid),
            "DateTime" => Ok(PropertyType::DateTime),
            "Box" => Ok(PropertyType::Box),
            "Vector2D" => Ok(PropertyType::Vector2D),
            "Vector" => Ok(PropertyType::Vector),
            "Quat" => Ok(PropertyType::Quat),
            "Rotator" => Ok(PropertyType::Rotator),
            "LinearColor" => Ok(PropertyType::LinearColor),
            "IntProperty" => Ok(PropertyType::IntProperty),
            "UInt32Property" => Ok(PropertyType::UInt32Property),
            "FloatProperty" => Ok(PropertyType::FloatProperty),
            "BoolProperty" => Ok(PropertyType::BoolProperty),
            "ByteProperty" => Ok(PropertyType::ByteProperty),
            "StructProperty" => Ok(PropertyType::StructProperty),
            "ArrayProperty" => Ok(PropertyType::ArrayProperty),
            "ObjectProperty" => Ok(PropertyType::ObjectProperty),
            "StrProperty" => Ok(PropertyType::StrProperty),
            "NameProperty" => Ok(PropertyType::NameProperty),
            "TextProperty" => Ok(PropertyType::TextProperty),
            "MulticastInlineDelegateProperty" => Ok(PropertyType::MulticastInlineDelegateProperty),
            "SetProperty" => Ok(PropertyType::SetProperty),
            "MapProperty" => Ok(PropertyType::MapProperty),
            _ => Ok(PropertyType::Other(t)),
        }
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        write_string(
            writer,
            match &self {
                PropertyType::Guid => "Guid",
                PropertyType::DateTime => "DateTime",
                PropertyType::Box => "Box",
                PropertyType::Vector2D => "Vector2D",
                PropertyType::Vector => "Vector",
                PropertyType::Quat => "Quat",
                PropertyType::Rotator => "Rotator",
                PropertyType::LinearColor => "LinearColor",
                PropertyType::IntProperty => "IntProperty",
                PropertyType::UInt32Property => "UInt32Property",
                PropertyType::FloatProperty => "FloatProperty",
                PropertyType::BoolProperty => "BoolProperty",
                PropertyType::ByteProperty => "ByteProperty",
                PropertyType::StructProperty => "StructProperty",
                PropertyType::ArrayProperty => "ArrayProperty",
                PropertyType::ObjectProperty => "ObjectProperty",
                PropertyType::StrProperty => "StrProperty",
                PropertyType::NameProperty => "NameProperty",
                PropertyType::TextProperty => "TextProperty",
                PropertyType::MulticastInlineDelegateProperty => "MulticastInlineDelegateProperty",
                PropertyType::SetProperty => "SetProperty",
                PropertyType::MapProperty => "MapProperty",
                PropertyType::Other(t) => t,
            },
        )?;
        Ok(())
    }
}

type Int = i32;
type UInt32 = u32;
type Float = f32;
type Bool = bool;
type Byte = String;
type StructKey = uuid::Uuid;

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct MapEntry {
    pub key: ValueKey,
    pub value: ValueStruct,
}
impl MapEntry {
    fn read<R: Read>(
        key_type: &PropertyType,
        value_type: &PropertyType,
        reader: &mut R,
    ) -> TResult<MapEntry> {
        let key = ValueKey::read(key_type, reader)?;
        let value = ValueStruct::read(value_type, reader)?;
        Ok(Self { key, value })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        self.key.write(writer)?;
        self.value.write(writer)?;
        Ok(())
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct MulticastInlineDelegate(Vec<MulticastInlineDelegateEntry>);
impl MulticastInlineDelegate {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self(read_array(
            reader.read_u32::<LE>()?,
            reader,
            MulticastInlineDelegateEntry::read,
        )?))
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        writer.write_u32::<LE>(self.0.len() as u32)?;
        for entry in &self.0 {
            entry.write(writer)?;
        }
        Ok(())
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct MulticastInlineDelegateEntry {
    pub path: String,
    pub name: String,
}
impl MulticastInlineDelegateEntry {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self {
            path: read_string(reader)?,
            name: read_string(reader)?,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        write_string(writer, &self.path)?;
        write_string(writer, &self.name)?;
        Ok(())
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct LinearColor {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
impl LinearColor {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self {
            r: reader.read_f32::<LE>()?,
            g: reader.read_f32::<LE>()?,
            b: reader.read_f32::<LE>()?,
            a: reader.read_f32::<LE>()?,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        writer.write_f32::<LE>(self.r)?;
        writer.write_f32::<LE>(self.g)?;
        writer.write_f32::<LE>(self.b)?;
        writer.write_f32::<LE>(self.a)?;
        Ok(())
    }
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Quat {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
impl Quat {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self {
            x: reader.read_f32::<LE>()?,
            y: reader.read_f32::<LE>()?,
            z: reader.read_f32::<LE>()?,
            w: reader.read_f32::<LE>()?,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        writer.write_f32::<LE>(self.x)?;
        writer.write_f32::<LE>(self.y)?;
        writer.write_f32::<LE>(self.z)?;
        writer.write_f32::<LE>(self.w)?;
        Ok(())
    }
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Rotator {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl Rotator {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self {
            x: reader.read_f32::<LE>()?,
            y: reader.read_f32::<LE>()?,
            z: reader.read_f32::<LE>()?,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        writer.write_f32::<LE>(self.x)?;
        writer.write_f32::<LE>(self.y)?;
        writer.write_f32::<LE>(self.z)?;
        Ok(())
    }
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Vector {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl Vector {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self {
            x: reader.read_f32::<LE>()?,
            y: reader.read_f32::<LE>()?,
            z: reader.read_f32::<LE>()?,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        writer.write_f32::<LE>(self.x)?;
        writer.write_f32::<LE>(self.y)?;
        writer.write_f32::<LE>(self.z)?;
        Ok(())
    }
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Vector2D {
    pub x: f32,
    pub y: f32,
}
impl Vector2D {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self {
            x: reader.read_f32::<LE>()?,
            y: reader.read_f32::<LE>()?,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        writer.write_f32::<LE>(self.x)?;
        writer.write_f32::<LE>(self.y)?;
        Ok(())
    }
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Box {
    pub a: Vector,
    pub b: Vector,
}
impl Box {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        let a = Vector::read(reader)?;
        let b = Vector::read(reader)?;
        reader.read_u8()?;
        Ok(Self { a, b })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        self.a.write(writer)?;
        self.b.write(writer)?;
        Ok(())
    }
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Text {
    pub magic: u8,
    pub value: String,
}
impl<R: Read> Readable<R> for Text {
    fn read(reader: &mut R) -> TResult<Self> {
        let magic = reader.read_u8()?;
        match magic {
            2 => {
                reader.read_u64::<LE>()?;
            }
            0 | 8 => {
                reader.read_u64::<LE>()?;
                reader.read_u8()?;
                read_string(reader)?;
            }
            _ => return Err(crate::error::Error::Other("unknown magic byte for Text")),
        };
        Ok(Self {
            magic,
            value: read_string(reader)?,
        })
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ValueBase {
    Guid(uuid::Uuid),
    DateTime(u64),
    Int(i32),
    UInt32(u32),
    Float(f32),
    Bool(bool),
    Byte(String),
    Quat(Quat),
    LinearColor(LinearColor),
    Rotator(Rotator),
    Vector(Vector),
    Vector2D(Vector2D),
    Box(Box),
    Name(String),
    Str(String),
    Object(String),
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ValueStruct {
    Base(ValueBase),
    Struct(Vec<Property>),
}

// Values used as keys for SetProperty and MapProperty
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ValueKey {
    Base(ValueBase),
    Struct(StructKey),
}

// Array of values used by ArrayProperty
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ValueArray {
    Int(Vec<Int>),
    UInt32(Vec<UInt32>),
    Float(Vec<Float>),
    Byte(Vec<Byte>),
    Str(Vec<String>),
    Name(Vec<String>),
    Object(Vec<String>),
    Box(Vec<Box>),
    Struct {
        _type: String,
        name: String,
        struct_type: PropertyType,
        id: uuid::Uuid,
        value: Vec<ValueStruct>,
    },
}

impl ValueBase {
    fn read<R: Read>(t: &PropertyType, reader: &mut R) -> TResult<Option<ValueBase>> {
        Ok(match t {
            PropertyType::Guid => Some(ValueBase::Guid(uuid::Uuid::read(reader)?)),
            PropertyType::DateTime => Some(ValueBase::DateTime(reader.read_u64::<LE>()?)),
            PropertyType::IntProperty => Some(ValueBase::Int(reader.read_i32::<LE>()?)),
            PropertyType::UInt32Property => Some(ValueBase::UInt32(reader.read_u32::<LE>()?)),
            PropertyType::FloatProperty => Some(ValueBase::Float(reader.read_f32::<LE>()?)),
            PropertyType::BoolProperty => Some(ValueBase::Bool(reader.read_u8()? > 0)),
            PropertyType::Quat => Some(ValueBase::Quat(Quat::read(reader)?)),
            PropertyType::LinearColor => Some(ValueBase::LinearColor(LinearColor::read(reader)?)),
            PropertyType::Rotator => Some(ValueBase::Rotator(Rotator::read(reader)?)),
            PropertyType::Vector => Some(ValueBase::Vector(Vector::read(reader)?)),
            PropertyType::Vector2D => Some(ValueBase::Vector2D(Vector2D::read(reader)?)),
            PropertyType::Box => Some(ValueBase::Box(Box::read(reader)?)),
            PropertyType::NameProperty => Some(ValueBase::Name(read_string(reader)?)),
            PropertyType::StrProperty => Some(ValueBase::Str(read_string(reader)?)),
            PropertyType::ObjectProperty => Some(ValueBase::Object(read_string(reader)?)),
            PropertyType::ByteProperty => Some(ValueBase::Byte(read_string(reader)?)),
            _ => None,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        match &self {
            ValueBase::Guid(v) => v.write(writer)?,
            ValueBase::DateTime(v) => writer.write_u64::<LE>(*v)?,
            ValueBase::Int(v) => writer.write_i32::<LE>(*v)?,
            ValueBase::UInt32(v) => writer.write_u32::<LE>(*v)?,
            ValueBase::Float(v) => writer.write_f32::<LE>(*v)?,
            ValueBase::Bool(v) => writer.write_u8(u8::from(*v))?,
            ValueBase::Quat(v) => v.write(writer)?,
            ValueBase::LinearColor(v) => v.write(writer)?,
            ValueBase::Rotator(v) => v.write(writer)?,
            ValueBase::Vector(v) => v.write(writer)?,
            ValueBase::Vector2D(v) => v.write(writer)?,
            ValueBase::Box(v) => v.write(writer)?,
            ValueBase::Name(v) => write_string(writer, v)?,
            ValueBase::Str(v) => write_string(writer, v)?,
            ValueBase::Object(v) => write_string(writer, v)?,
            ValueBase::Byte(v) => write_string(writer, v)?,
        };
        Ok(())
    }
}
impl ValueStruct {
    fn read<R: Read>(t: &PropertyType, reader: &mut R) -> TResult<ValueStruct> {
        Ok(if let Some(base) = ValueBase::read(t, reader)? {
            ValueStruct::Base(base)
        } else {
            ValueStruct::Struct(read_properties_until_none(reader)?)
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        match self {
            ValueStruct::Base(v) => v.write(writer)?,
            ValueStruct::Struct(v) => write_properties_none_terminated(writer, v)?,
        }
        Ok(())
    }
}
impl ValueKey {
    fn read<R: Read>(t: &PropertyType, reader: &mut R) -> TResult<ValueKey> {
        Ok(if let Some(base) = ValueBase::read(t, reader)? {
            ValueKey::Base(base)
        } else {
            ValueKey::Struct(uuid::Uuid::read(reader)?)
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        match self {
            ValueKey::Base(v) => v.write(writer)?,
            ValueKey::Struct(v) => v.write(writer)?,
        }
        Ok(())
    }
}
impl ValueArray {
    fn read<R: Read>(t: &PropertyType, reader: &mut R) -> TResult<ValueArray> {
        let count = reader.read_u32::<LE>()?;
        Ok(match t {
            PropertyType::IntProperty => {
                ValueArray::Int(read_array(count, reader, |r| Ok(r.read_i32::<LE>()?))?)
            }
            PropertyType::UInt32Property => {
                ValueArray::UInt32(read_array(count, reader, |r| Ok(r.read_u32::<LE>()?))?)
            }
            PropertyType::FloatProperty => {
                ValueArray::Float(read_array(count, reader, |r| Ok(r.read_f32::<LE>()?))?)
            }
            PropertyType::ByteProperty => ValueArray::Byte(read_array(count, reader, read_string)?),
            PropertyType::StrProperty => ValueArray::Byte(read_array(count, reader, read_string)?),
            PropertyType::NameProperty => ValueArray::Byte(read_array(count, reader, read_string)?),
            PropertyType::ObjectProperty => {
                ValueArray::Byte(read_array(count, reader, read_string)?)
            }
            PropertyType::Box => ValueArray::Box(read_array(count, reader, Box::read)?),
            PropertyType::StructProperty => {
                let _type = read_string(reader)?;
                let name = read_string(reader)?;
                let _size = reader.read_u64::<LE>()?;
                let struct_type = PropertyType::read(reader)?;
                let id = uuid::Uuid::read(reader)?;
                reader.read_u8()?;
                let mut value = vec![];
                for _ in 0..count {
                    value.push(ValueStruct::read(&struct_type, reader)?);
                }
                ValueArray::Struct {
                    _type,
                    name,
                    struct_type,
                    id,
                    value,
                }
            }
            _ => return Err(crate::error::Error::UnknownArrayType(format!("{t:?}"))),
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        match &self {
            ValueArray::Int(v) => {
                writer.write_u32::<LE>(v.len() as u32)?;
                for i in v {
                    writer.write_i32::<LE>(*i)?;
                }
            }
            ValueArray::UInt32(v) => {
                writer.write_u32::<LE>(v.len() as u32)?;
                for i in v {
                    writer.write_u32::<LE>(*i)?;
                }
            }
            ValueArray::Float(v) => {
                writer.write_u32::<LE>(v.len() as u32)?;
                for i in v {
                    writer.write_f32::<LE>(*i)?;
                }
            }
            ValueArray::Byte(v)
            | ValueArray::Str(v)
            | ValueArray::Object(v)
            | ValueArray::Name(v) => {
                writer.write_u32::<LE>(v.len() as u32)?;
                for i in v {
                    write_string(writer, i)?;
                }
            }
            ValueArray::Box(v) => {
                writer.write_u32::<LE>(v.len() as u32)?;
                for i in v {
                    i.write(writer)?;
                }
            }
            ValueArray::Struct {
                _type,
                name,
                struct_type,
                id,
                value,
            } => {
                writer.write_u32::<LE>(value.len() as u32)?;
                write_string(writer, _type)?;
                write_string(writer, name)?;
                let mut buf = vec![];
                for v in value {
                    v.write(&mut buf)?;
                }
                writer.write_u64::<LE>(buf.len() as u64)?;
                struct_type.write(writer)?;
                id.write(writer)?;
                writer.write_u8(0)?;
                writer.write_all(&buf)?;
            }
        }
        Ok(())
    }
}

// Values with IDs present in the top level object and StructProperty
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PropertyMeta {
    Int {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: Int,
    },
    UInt32 {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: UInt32,
    },
    Float {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: Float,
    },
    Bool {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: Bool,
    },
    Byte {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: Byte,
        enum_type: String,
    },
    Str {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: String,
    },
    Name {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: String,
    },
    Object {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: String,
    },
    Text {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: Text,
    },
    MulticastInlineDelegate {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: MulticastInlineDelegate,
    },
    Set {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        set_type: PropertyType,
        value: Vec<ValueKey>,
    },
    Map {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        key_type: PropertyType,
        value_type: PropertyType,
        value: Vec<MapEntry>,
    },
    Struct {
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: ValueStruct,
        struct_type: PropertyType,
        struct_id: uuid::Uuid,
    },
    Array {
        array_type: PropertyType,
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<uuid::Uuid>,
        value: ValueArray,
    },
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Property {
    pub name: String,
    pub value: PropertyMeta,
}

impl Property {
    fn read<R: Read>(reader: &mut R) -> TResult<Option<Property>> {
        let name = read_string(reader)?;
        if name == "None" {
            Ok(None)
        } else {
            let t = PropertyType::read(reader)?;
            let _size = reader.read_u64::<LE>()?;
            let value = PropertyMeta::read(t, reader)?;
            Ok(Some(Property { name, value }))
        }
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        write_string(writer, &self.name)?;
        self.value.get_type().write(writer)?;

        let mut buf = vec![];
        let size = self.value.write(&mut buf)?;

        //writer.write_u64::<LE>(buf.len() as u64)?;
        writer.write_u64::<LE>(size as u64)?;
        writer.write_all(&buf[..])?;
        Ok(())
    }
}

impl PropertyMeta {
    fn get_type(&self) -> PropertyType {
        match &self {
            PropertyMeta::Int { .. } => PropertyType::IntProperty,
            PropertyMeta::UInt32 { .. } => PropertyType::UInt32Property,
            PropertyMeta::Float { .. } => PropertyType::FloatProperty,
            PropertyMeta::Bool { .. } => PropertyType::BoolProperty,
            PropertyMeta::Byte { .. } => PropertyType::ByteProperty,
            PropertyMeta::Name { .. } => PropertyType::NameProperty,
            PropertyMeta::Str { .. } => PropertyType::StrProperty,
            PropertyMeta::Object { .. } => PropertyType::ObjectProperty,
            PropertyMeta::Text { .. } => PropertyType::TextProperty,
            PropertyMeta::MulticastInlineDelegate { .. } => {
                PropertyType::MulticastInlineDelegateProperty
            }
            PropertyMeta::Set { .. } => PropertyType::SetProperty,
            PropertyMeta::Map { .. } => PropertyType::MapProperty,
            PropertyMeta::Struct { .. } => PropertyType::StructProperty,
            PropertyMeta::Array { .. } => PropertyType::ArrayProperty,
        }
    }
    fn read<R: Read>(t: PropertyType, reader: &mut R) -> TResult<PropertyMeta> {
        match t {
            PropertyType::IntProperty => Ok(PropertyMeta::Int {
                id: read_optional_uuid(reader)?,
                value: reader.read_i32::<LE>()?,
            }),
            PropertyType::UInt32Property => Ok(PropertyMeta::UInt32 {
                id: read_optional_uuid(reader)?,
                value: reader.read_u32::<LE>()?,
            }),
            PropertyType::FloatProperty => Ok(PropertyMeta::Float {
                id: read_optional_uuid(reader)?,
                value: reader.read_f32::<LE>()?,
            }),
            PropertyType::BoolProperty => Ok(PropertyMeta::Bool {
                value: reader.read_u8()? > 0,
                id: read_optional_uuid(reader)?,
            }),
            PropertyType::ByteProperty => Ok(PropertyMeta::Byte {
                enum_type: read_string(reader)?,
                id: read_optional_uuid(reader)?,
                value: read_string(reader)?,
            }),
            PropertyType::NameProperty => Ok(PropertyMeta::Name {
                id: read_optional_uuid(reader)?,
                value: read_string(reader)?,
            }),
            PropertyType::StrProperty => Ok(PropertyMeta::Str {
                id: read_optional_uuid(reader)?,
                value: read_string(reader)?,
            }),
            PropertyType::ObjectProperty => Ok(PropertyMeta::Object {
                id: read_optional_uuid(reader)?,
                value: read_string(reader)?,
            }),
            PropertyType::TextProperty => Ok(PropertyMeta::Text {
                id: read_optional_uuid(reader)?,
                value: Text::read(reader)?,
            }),
            PropertyType::MulticastInlineDelegateProperty => {
                Ok(PropertyMeta::MulticastInlineDelegate {
                    id: read_optional_uuid(reader)?,
                    value: MulticastInlineDelegate::read(reader)?,
                })
            }
            PropertyType::SetProperty => {
                let set_type = PropertyType::read(reader)?;
                let id = read_optional_uuid(reader)?;
                reader.read_u32::<LE>()?;
                let count = reader.read_u32::<LE>()?;
                match set_type {
                    PropertyType::StructProperty => Ok(PropertyMeta::Set {
                        id,
                        set_type,
                        value: read_array(count, reader, |r| {
                            Ok(ValueKey::Base(ValueBase::Guid(uuid::Uuid::read(r)?)))
                        })?,
                    }),
                    _ => return Err(crate::error::Error::UnknownSetType(format!("{set_type:?}"))),
                }
            }
            PropertyType::MapProperty => {
                let key_type = PropertyType::read(reader)?;
                let value_type = PropertyType::read(reader)?;
                let id = read_optional_uuid(reader)?;
                reader.read_u32::<LE>()?;
                let count = reader.read_u32::<LE>()?;
                let mut value = vec![];
                for _ in 0..count {
                    value.push(MapEntry::read(&key_type, &value_type, reader)?)
                }
                Ok(PropertyMeta::Map {
                    key_type,
                    value_type,
                    id,
                    value,
                })
            }
            PropertyType::StructProperty => {
                let struct_type = PropertyType::read(reader)?;
                let struct_id = uuid::Uuid::read(reader)?;
                let id = read_optional_uuid(reader)?;
                let value = ValueStruct::read(&struct_type, reader)?;
                Ok(PropertyMeta::Struct {
                    struct_type,
                    struct_id,
                    id,
                    value,
                })
            }
            PropertyType::ArrayProperty => {
                let array_type = PropertyType::read(reader)?;
                let id = read_optional_uuid(reader)?;
                let value = ValueArray::read(&array_type, reader)?;

                Ok(PropertyMeta::Array {
                    array_type,
                    id,
                    value,
                })
            }
            _ => return Err(crate::error::Error::UnknownPropertyMeta(format!("{t:?}"))),
        }
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<usize> {
        Ok(match self {
            PropertyMeta::Int { id, value } => {
                write_optional_uuid(writer, *id)?;
                writer.write_i32::<LE>(*value)?;
                4
            }
            PropertyMeta::UInt32 { id, value } => {
                write_optional_uuid(writer, *id)?;
                writer.write_u32::<LE>(*value)?;
                4
            }
            PropertyMeta::Float { id, value } => {
                write_optional_uuid(writer, *id)?;
                writer.write_f32::<LE>(*value)?;
                4
            }
            PropertyMeta::Bool { id, value } => {
                writer.write_u8(u8::from(*value))?;
                write_optional_uuid(writer, *id)?;
                0
            }
            PropertyMeta::Byte {
                enum_type,
                id,
                value,
            } => {
                write_string(writer, enum_type)?;
                write_optional_uuid(writer, *id)?;
                write_string(writer, value)?;
                61
            }
            PropertyMeta::Name { id, value } => {
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                write_string(&mut buf, value)?;
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
            PropertyMeta::Str { id, value } => {
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                write_string(&mut buf, value)?;
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
            PropertyMeta::Object { id, value } => {
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                write_string(&mut buf, value)?;
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
            PropertyMeta::Text { id, /* value */ .. } => {
                write_optional_uuid(writer, *id)?;
                todo!("TODO: write PropertyMeta::Text");
                //write_string(writer, value)?;
            }
            PropertyMeta::MulticastInlineDelegate { id, value } => {
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                value.write(&mut buf)?;
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
            PropertyMeta::Set {
                id,
                set_type,
                value,
            } => {
                set_type.write(writer)?;
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                buf.write_u32::<LE>(0)?;
                buf.write_u32::<LE>(value.len() as u32)?;
                for v in value {
                    v.write(&mut buf)?;
                }
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
            PropertyMeta::Map {
                key_type,
                value_type,
                id,
                value,
            } => {
                key_type.write(writer)?;
                value_type.write(writer)?;
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                buf.write_u32::<LE>(0)?;
                buf.write_u32::<LE>(value.len() as u32)?;
                for v in value {
                    v.write(&mut buf)?;
                }
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
            PropertyMeta::Struct {
                struct_type,
                struct_id,
                id,
                value,
            } => {
                struct_type.write(writer)?;
                struct_id.write(writer)?;
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                value.write(&mut buf)?;
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
            PropertyMeta::Array {
                array_type,
                id,
                value,
            } => {
                array_type.write(writer)?;
                write_optional_uuid(writer, *id)?;
                let mut buf = vec![];
                value.write(&mut buf)?;
                let size = buf.len();
                writer.write_all(&buf)?;
                size
            }
        })
    }
}

#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct CustomFormatData {
    pub id: uuid::Uuid,
    pub value: i32,
}
impl<R: Read> Readable<R> for CustomFormatData {
    fn read(reader: &mut R) -> TResult<Self> {
        Ok(CustomFormatData {
            id: uuid::Uuid::read(reader)?,
            value: reader.read_i32::<LE>()?,
        })
    }
}
impl<W: Write> Writable<W> for CustomFormatData {
    fn write(&self, writer: &mut W) -> TResult<()> {
        self.id.write(writer)?;
        writer.write_i32::<LE>(self.value)?;
        Ok(())
    }
}

#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Header {
    pub save_game_version: u32,
    pub package_version: u32,
    pub engine_version_major: u16,
    pub engine_version_minor: u16,
    pub engine_version_patch: u16,
    pub engine_version_build: u32,
    pub engine_version: String,
    pub custom_format_version: u32,
    pub custom_format: Vec<CustomFormatData>,
}
impl<R: Read> Readable<R> for Header {
    fn read(reader: &mut R) -> TResult<Self> {
        if reader.read_u32::<LE>()? != u32::from_le_bytes(*b"GVAS") {
            return Err(crate::error::Error::BadMagic());
        }
        Ok(Header {
            save_game_version: reader.read_u32::<LE>()?,
            package_version: reader.read_u32::<LE>()?,
            engine_version_major: reader.read_u16::<LE>()?,
            engine_version_minor: reader.read_u16::<LE>()?,
            engine_version_patch: reader.read_u16::<LE>()?,
            engine_version_build: reader.read_u32::<LE>()?,
            engine_version: read_string(reader)?,
            custom_format_version: reader.read_u32::<LE>()?,
            custom_format: read_array(reader.read_u32::<LE>()?, reader, |r| {
                CustomFormatData::read(r)
            })?,
        })
    }
}
impl<W: Write> Writable<W> for Header {
    fn write(&self, writer: &mut W) -> TResult<()> {
        writer.write_u32::<LE>(u32::from_le_bytes(*b"GVAS"))?;
        writer.write_u32::<LE>(self.save_game_version)?;
        writer.write_u32::<LE>(self.package_version)?;
        writer.write_u16::<LE>(self.engine_version_major)?;
        writer.write_u16::<LE>(self.engine_version_minor)?;
        writer.write_u16::<LE>(self.engine_version_patch)?;
        writer.write_u32::<LE>(self.engine_version_build)?;
        write_string(writer, &self.engine_version)?;
        writer.write_u32::<LE>(self.custom_format_version)?;
        writer.write_u32::<LE>(self.custom_format.len() as u32)?;
        for cf in &self.custom_format {
            cf.write(writer)?;
        }
        Ok(())
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Root {
    pub save_game_type: String,
    pub root: Vec<Property>,
}
impl Root {
    fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        Ok(Self {
            save_game_type: read_string(reader)?,
            root: read_properties_until_none(reader)?,
        })
    }
    fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        write_string(writer, &self.save_game_type)?;
        write_properties_none_terminated(writer, &self.root)?;
        Ok(())
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Save {
    pub header: Header,
    pub root: Root,
}
impl Save {
    pub fn read<R: Read>(reader: &mut R) -> TResult<Self> {
        let header = Header::read(reader)?;
        let root = Root::read(reader)?;
        Ok(Self { header, root })
    }
    pub fn write<W: Write>(&self, writer: &mut W) -> TResult<()> {
        self.header.write(writer)?;
        self.root.write(writer)?;
        writer.write_u32::<LE>(0)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use crate::*;
    use pretty_assertions::assert_eq;

    use std::io::Cursor;

    static SAVE: &'static [u8] = include_bytes!("../drg-save-test.sav");
    #[test]
    fn test_header() -> TResult<()> {
        let original = vec![
            0x47, 0x56, 0x41, 0x53, 0x02, 0x00, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00, 0x04, 0x00,
            0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x2B, 0x2B,
            0x55, 0x45, 0x34, 0x2B, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x2D, 0x34, 0x2E,
            0x32, 0x35, 0x50, 0x6C, 0x75, 0x73, 0x00, 0x03, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00,
            0x00, 0xFA, 0x7A, 0xF5, 0xFC, 0x83, 0x42, 0x76, 0x50, 0x58, 0xE6, 0xA9, 0xB9, 0x32,
            0x2D, 0xA0, 0xFF, 0x3D, 0x00, 0x00, 0x00, 0xF3, 0x7A, 0xBB, 0x24, 0x83, 0x4F, 0x46,
            0x56, 0xC2, 0x2D, 0x2F, 0x1F, 0xFF, 0x96, 0xAD, 0x49, 0x05, 0x00, 0x00, 0x00, 0x29,
            0x23, 0xA5, 0x76, 0xB5, 0x45, 0x23, 0x09, 0x41, 0xD8, 0xAE, 0x98, 0xD8, 0x6A, 0x2F,
            0xCF, 0x02, 0x00, 0x00, 0x00, 0x07, 0x69, 0xBC, 0x5F, 0xAE, 0x40, 0xC8, 0x55, 0x84,
            0xF1, 0x67, 0x8E, 0x3F, 0xF1, 0xFF, 0x5E, 0x01, 0x00, 0x00, 0x00, 0x12, 0xE4, 0x26,
            0xFB, 0x4D, 0x4B, 0x15, 0x1F, 0x0A, 0x55, 0x72, 0x93, 0x70, 0x2F, 0x1D, 0x96, 0x03,
            0x00, 0x00, 0x00, 0x22, 0xD5, 0x54, 0x9C, 0xBE, 0x4F, 0x26, 0xA8, 0x46, 0x07, 0x21,
            0x94, 0xD0, 0x82, 0xB4, 0x61, 0x1E, 0x00, 0x00, 0x00, 0xE4, 0x32, 0xD8, 0xB0, 0x0D,
            0x4F, 0x89, 0x1F, 0xB7, 0x7E, 0xCF, 0xAC, 0xA2, 0x4A, 0xFD, 0x36, 0x0A, 0x00, 0x00,
            0x00, 0x28, 0x43, 0xC6, 0xE1, 0x53, 0x4D, 0x2C, 0xA2, 0x86, 0x8E, 0x6C, 0xA3, 0x8C,
            0xBD, 0x17, 0x64, 0x00, 0x00, 0x00, 0x00, 0x3C, 0xC1, 0x5E, 0x37, 0xFB, 0x48, 0xE4,
            0x06, 0xF0, 0x84, 0x00, 0xB5, 0x7E, 0x71, 0x2A, 0x26, 0x04, 0x00, 0x00, 0x00, 0xED,
            0x68, 0xB0, 0xE4, 0xE9, 0x42, 0x94, 0xF4, 0x0B, 0xDA, 0x31, 0xA2, 0x41, 0xBB, 0x46,
            0x2E, 0x26, 0x00, 0x00, 0x00, 0x3F, 0x74, 0xFC, 0xCF, 0x80, 0x44, 0xB0, 0x43, 0xDF,
            0x14, 0x91, 0x93, 0x73, 0x20, 0x1D, 0x17, 0x25, 0x00, 0x00, 0x00, 0xB5, 0x49, 0x2B,
            0xB0, 0xE9, 0x44, 0x20, 0xBB, 0xB7, 0x32, 0x04, 0xA3, 0x60, 0x03, 0xE4, 0x52, 0x02,
            0x00, 0x00, 0x00, 0x5C, 0x10, 0xE4, 0xA4, 0xB5, 0x49, 0xA1, 0x59, 0xC4, 0x40, 0xC5,
            0xA7, 0xEE, 0xDF, 0x7E, 0x54, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x31, 0xC8, 0x39, 0xDC,
            0x47, 0xE6, 0x5A, 0x17, 0x9C, 0x44, 0x9A, 0x7C, 0x8E, 0x1C, 0x3E, 0x00, 0x00, 0x00,
            0x00, 0x33, 0x1B, 0xF0, 0x78, 0x98, 0x4F, 0xEA, 0xEB, 0xEA, 0x84, 0xB4, 0xB9, 0xA2,
            0x5A, 0xB9, 0xCC, 0x04, 0x00, 0x00, 0x00, 0x0F, 0x38, 0x31, 0x66, 0xE0, 0x43, 0x4D,
            0x2D, 0x27, 0xCF, 0x09, 0x80, 0x5A, 0xA9, 0x56, 0x69, 0x00, 0x00, 0x00, 0x00, 0x9F,
            0x8B, 0xF8, 0x12, 0xFC, 0x4A, 0x75, 0x88, 0x0C, 0xD9, 0x7C, 0xA6, 0x29, 0xBD, 0x3A,
            0x38, 0x2B, 0x00, 0x00, 0x00, 0x4C, 0xE7, 0x5A, 0x7B, 0x10, 0x4C, 0x70, 0xD2, 0x98,
            0x57, 0x58, 0xA9, 0x5A, 0x2A, 0x21, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x18, 0x69, 0x29,
            0xD7, 0xDD, 0x4B, 0xD6, 0x1D, 0xA8, 0x64, 0xE2, 0x9D, 0x84, 0x38, 0xC1, 0x3C, 0x03,
            0x00, 0x00, 0x00, 0x78, 0x52, 0xA1, 0xC2, 0xFE, 0x4A, 0xE7, 0xBF, 0xFF, 0x90, 0x17,
            0x6C, 0x55, 0xF7, 0x1D, 0x53, 0x01, 0x00, 0x00, 0x00, 0xD4, 0xA3, 0xAC, 0x6E, 0xC1,
            0x4C, 0xEC, 0x40, 0xED, 0x8B, 0x86, 0xB7, 0xC5, 0x8F, 0x42, 0x09, 0x03, 0x00, 0x00,
            0x00, 0xDD, 0x75, 0xE5, 0x29, 0x27, 0x46, 0xA3, 0xE0, 0x76, 0xD2, 0x10, 0x9D, 0xEA,
            0xDC, 0x2C, 0x23, 0x11, 0x00, 0x00, 0x00, 0x5D, 0xA6, 0x43, 0xAF, 0x47, 0x49, 0xD3,
            0x7F, 0x8E, 0x3E, 0x73, 0x98, 0x05, 0xBB, 0xC1, 0xD9, 0x07, 0x00, 0x00, 0x00, 0xEC,
            0x6C, 0x26, 0x6B, 0x8F, 0x4B, 0xC7, 0x1E, 0xD9, 0xE4, 0x0B, 0xA3, 0x07, 0xFC, 0x42,
            0x09, 0x01, 0x00, 0x00, 0x00, 0x61, 0x3D, 0xF7, 0x0D, 0xEA, 0x47, 0x3F, 0xA2, 0xE9,
            0x89, 0x27, 0xB7, 0x9A, 0x49, 0x41, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x86, 0x18, 0x1D,
            0x60, 0x84, 0x4F, 0x64, 0xAC, 0xDE, 0xD3, 0x16, 0xAA, 0xD6, 0xC7, 0xEA, 0x0D, 0x1F,
            0x00, 0x00, 0x00, 0xD6, 0xBC, 0xFF, 0x9D, 0x58, 0x01, 0x4F, 0x49, 0x82, 0x12, 0x21,
            0xE2, 0x88, 0xA8, 0x92, 0x3C, 0x0A, 0x00, 0x00, 0x00, 0xAC, 0xD0, 0xAE, 0xF2, 0x6F,
            0x41, 0xFE, 0x9A, 0x7F, 0xAA, 0x64, 0x86, 0xFC, 0xD6, 0x26, 0xFA, 0x01, 0x00, 0x00,
            0x00, 0x0B, 0x1F, 0x4F, 0x17, 0xA5, 0x45, 0xC6, 0xB4, 0xE8, 0x2E, 0x3F, 0xB1, 0x7D,
            0x91, 0xFB, 0xD0, 0x0A, 0x00, 0x00, 0x00, 0x83, 0x4A, 0xF9, 0x35, 0x6C, 0x40, 0x58,
            0xE2, 0xF5, 0x09, 0x18, 0xA3, 0x7C, 0x24, 0x10, 0x96, 0x25, 0x00, 0x00, 0x00, 0x6E,
            0xC1, 0x8F, 0xB6, 0xE2, 0x42, 0x1B, 0x8B, 0x5C, 0x21, 0x53, 0xB4, 0xFE, 0x44, 0x88,
            0x05, 0x01, 0x00, 0x00, 0x00, 0x06, 0x85, 0xE1, 0xB2, 0xC2, 0xCF, 0x73, 0x42, 0xBB,
            0xF4, 0x4E, 0xA5, 0x07, 0xBA, 0x8B, 0x75, 0x01, 0x00, 0x00, 0x00, 0x50, 0x32, 0x68,
            0x54, 0xAF, 0x48, 0x99, 0x80, 0x96, 0x98, 0xC8, 0x8B, 0xB7, 0xF9, 0xAD, 0xFB, 0x00,
            0x00, 0x00, 0x00, 0x19, 0x4D, 0x0C, 0x43, 0x70, 0x49, 0x54, 0x71, 0x69, 0x9B, 0x69,
            0x87, 0xE5, 0xB0, 0x90, 0xDF, 0x0E, 0x00, 0x00, 0x00, 0xBD, 0x32, 0xFE, 0xAA, 0x14,
            0x4C, 0x95, 0x53, 0x25, 0x5E, 0x6A, 0xB6, 0xDD, 0xD1, 0x32, 0x10, 0x01, 0x00, 0x00,
            0x00, 0x8E, 0xE1, 0xAF, 0x23, 0x58, 0x4E, 0xE1, 0x4C, 0x52, 0xC2, 0x61, 0x8D, 0xB7,
            0xBE, 0x53, 0xB9, 0x0B, 0x00, 0x00, 0x00, 0xEA, 0xB7, 0x62, 0xA4, 0x3A, 0x4E, 0x99,
            0xF4, 0x1F, 0xEC, 0xC1, 0x99, 0xB2, 0xE1, 0x24, 0x82, 0x02, 0x00, 0x00, 0x00, 0xBD,
            0xFD, 0xB5, 0x2E, 0x10, 0x4D, 0xAC, 0x01, 0x8F, 0xF3, 0x36, 0x81, 0xDA, 0xA5, 0x93,
            0x33, 0x05, 0x00, 0x00, 0x00, 0x4F, 0x35, 0x9D, 0x50, 0x2F, 0x49, 0xE6, 0xF6, 0xB2,
            0x85, 0x49, 0xA7, 0x1C, 0x63, 0x3C, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x9E, 0x7F,
            0x71, 0x3A, 0x49, 0xB0, 0xE9, 0x32, 0x91, 0xB3, 0x88, 0x07, 0x81, 0x38, 0x1B, 0x06,
            0x00, 0x00, 0x00, 0x40, 0xEB, 0x56, 0x4A, 0xDC, 0x11, 0xF5, 0x10, 0x7E, 0x34, 0xD3,
            0x92, 0xE7, 0x6A, 0xC9, 0xB2, 0x02, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x8A, 0xD7, 0x97,
            0x46, 0x58, 0xE8, 0xB5, 0x19, 0xA8, 0xBA, 0xB4, 0x46, 0x7D, 0x48, 0x11, 0x00, 0x00,
            0x00, 0x86, 0xF8, 0x79, 0x55, 0x1F, 0x4C, 0x3A, 0x93, 0x7B, 0x08, 0xBA, 0x83, 0x2F,
            0xB9, 0x61, 0x63, 0x01, 0x00, 0x00, 0x00, 0x52, 0xBE, 0x2F, 0x61, 0x0B, 0x40, 0x53,
            0xDA, 0x91, 0x4F, 0x0D, 0x91, 0x7C, 0x85, 0xB1, 0x9F, 0x01, 0x00, 0x00, 0x00, 0x36,
            0x7A, 0x23, 0xA4, 0xC9, 0x41, 0xEA, 0xCA, 0xF8, 0x18, 0xA2, 0x8F, 0xF3, 0x1B, 0x68,
            0x58, 0x04, 0x00, 0x00, 0x00, 0x75, 0x3F, 0x4E, 0x80, 0x49, 0x4B, 0x88, 0x70, 0x06,
            0x8C, 0xD6, 0xA4, 0xDC, 0xB6, 0x7E, 0x3C, 0x05, 0x00, 0x00, 0x00, 0xF2, 0x0A, 0x68,
            0xFB, 0xA3, 0x4B, 0xEF, 0x59, 0xB5, 0x19, 0xA8, 0xBA, 0x3D, 0x44, 0xC8, 0x73, 0x02,
            0x00, 0x00, 0x00, 0x0E, 0xB7, 0x50, 0x99, 0x17, 0x4E, 0x1A, 0xB4, 0x0D, 0xFA, 0xCC,
            0xBB, 0xD6, 0x7F, 0x81, 0x57, 0x01, 0x00, 0x00, 0x00, 0x96, 0x51, 0x96, 0xAB, 0xFC,
            0x08, 0xD8, 0x45, 0x8D, 0x22, 0xD7, 0xB7, 0x9E, 0x56, 0xAD, 0x78, 0x01, 0x00, 0x00,
            0x00,
        ];
        let mut reader = Cursor::new(&original);
        let header = Header::read(&mut reader)?;
        let mut reconstructed = vec![];
        header.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_uuid() -> TResult<()> {
        let id = uuid::uuid!("2eb5fdbd4d1001ac8ff33681daa59333");
        let mut writer = vec![];
        id.write(&mut writer)?;
        let mut reader = Cursor::new(&writer);
        let rid = uuid::Uuid::read(&mut reader)?;
        assert_eq!(id, rid);
        Ok(())
    }

    #[test]
    fn test_rw_save1() -> TResult<()> {
        let mut reader = Cursor::new(&SAVE);
        let obj = Save::read(&mut reader)?;
        let mut reconstructed: Vec<u8> = vec![];
        obj.write(&mut reconstructed)?;
        assert_eq!(SAVE, reconstructed);
        Ok(())
    }

    #[test]
    fn test_rw_property_meta() -> TResult<()> {
        let original = vec![
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
        ];
        let mut reader = Cursor::new(&original);
        let obj = PropertyMeta::read(PropertyType::IntProperty, &mut reader)?;
        let mut reconstructed: Vec<u8> = vec![];
        obj.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        assert_eq!(
            obj,
            PropertyMeta::Int {
                id: Some(uuid::uuid!("00000000000000000000000000000000")),
                value: 10
            }
        );
        Ok(())
    }

    #[test]
    fn test_rw_property_meta_str() -> TResult<()> {
        let original = vec![
            0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x33, 0x37, 0x30, 0x32, 0x34, 0x32, 0x34, 0x31,
            0x31, 0x32, 0x37, 0x39, 0x31, 0x34, 0x35, 0x39, 0x30, 0x31, 0x31, 0x38, 0x31, 0x36,
            0x37, 0x31, 0x34, 0x32, 0x32, 0x34, 0x39, 0x34, 0x33, 0x31, 0x31, 0x32, 0x35, 0x32,
            0x35, 0x33, 0x31, 0x34, 0x30, 0x34, 0x30, 0x39, 0x35, 0x32, 0x30, 0x35, 0x00,
        ];
        let mut reader = Cursor::new(&original);
        let obj = PropertyMeta::read(PropertyType::StrProperty, &mut reader)?;
        println!("{obj:#?}");
        let mut reconstructed: Vec<u8> = vec![];
        obj.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_read_int_property() -> TResult<()> {
        let bytes = b"\x0E\x00\x00\x00\x56\x65\x72\x73\x69\x6F\x6E\x4E\x75\x6D\x62\x65\x72\x00\x0C\x00\x00\x00\x49\x6E\x74\x50\x72\x6F\x70\x65\x72\x74\x79\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00";
        let mut reader = Cursor::new(bytes);
        assert_eq!(
            Property::read(&mut reader)?,
            Some(Property {
                name: "VersionNumber".to_string(),
                value: PropertyMeta::Int { id: None, value: 2 }
            })
        );
        Ok(())
    }

    #[test]
    fn test_read_struct_property() -> TResult<()> {
        let bytes = b"\x12\x00\x00\x00\x56\x61\x6E\x69\x74\x79\x4D\x61\x73\x74\x65\x72\x79\x53\x61\x76\x65\x00\x0F\x00\x00\x00\x53\x74\x72\x75\x63\x74\x50\x72\x6F\x70\x65\x72\x74\x79\x00\x8D\x00\x00\x00\x00\x00\x00\x00\x12\x00\x00\x00\x56\x61\x6E\x69\x74\x79\x4D\x61\x73\x74\x65\x72\x79\x53\x61\x76\x65\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x4C\x65\x76\x65\x6C\x00\x0C\x00\x00\x00\x49\x6E\x74\x50\x72\x6F\x70\x65\x72\x74\x79\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x8C\x00\x00\x00\x03\x00\x00\x00\x58\x50\x00\x0C\x00\x00\x00\x49\x6E\x74\x50\x72\x6F\x70\x65\x72\x74\x79\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x3A\x23\x00\x00\x1A\x00\x00\x00\x48\x61\x73\x41\x77\x61\x72\x64\x65\x64\x46\x6F\x72\x4F\x6C\x64\x50\x75\x72\x63\x68\x61\x73\x65\x73\x00\x0D\x00\x00\x00\x42\x6F\x6F\x6C\x50\x72\x6F\x70\x65\x72\x74\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x05\x00\x00\x00\x4E\x6F\x6E\x65\x00";
        let mut reader = Cursor::new(bytes);
        assert_eq!(
            Property::read(&mut reader)?,
            Some(Property {
                name: "VanityMasterySave".to_string(),
                value: PropertyMeta::Struct {
                    id: None,
                    value: ValueStruct::Struct(vec![
                        Property {
                            name: "Level".to_string(),
                            value: PropertyMeta::Int {
                                id: None,
                                value: 140,
                            },
                        },
                        Property {
                            name: "XP".to_string(),
                            value: PropertyMeta::Int {
                                id: None,
                                value: 9018,
                            },
                        },
                        Property {
                            name: "HasAwardedForOldPurchases".to_string(),
                            value: PropertyMeta::Bool {
                                id: None,
                                value: true,
                            },
                        },
                    ]),
                    struct_type: PropertyType::Other("VanityMasterySave".to_string()),
                    struct_id: uuid::uuid!("00000000000000000000000000000000"),
                }
            })
        );
        Ok(())
    }

    #[test]
    fn test_read_array_property() -> TResult<()> {
        let bytes = b"\x0C\x00\x00\x00\x53\x74\x61\x74\x49\x6E\x64\x69\x63\x65\x73\x00\x0E\x00\x00\x00\x41\x72\x72\x61\x79\x50\x72\x6F\x70\x65\x72\x74\x79\x00\x08\x00\x00\x00\x00\x00\x00\x00\x0C\x00\x00\x00\x49\x6E\x74\x50\x72\x6F\x70\x65\x72\x74\x79\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00";
        let mut reader = Cursor::new(bytes);
        assert_eq!(
            Property::read(&mut reader)?,
            Some(Property {
                name: "StatIndices".to_string(),
                value: PropertyMeta::Array {
                    array_type: PropertyType::IntProperty,
                    id: None,
                    value: ValueArray::Int(vec![0])
                }
            })
        );
        Ok(())
    }

    #[test]
    fn test_rw_property_int() -> TResult<()> {
        let original = vec![
            0x0E, 0x00, 0x00, 0x00, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x4E, 0x75, 0x6D,
            0x62, 0x65, 0x72, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F,
            0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00, 0x00,
        ];
        let mut reader = Cursor::new(&original);
        let property = Property::read(&mut reader)?.unwrap();
        println!("{property:#?}");
        let mut reconstructed: Vec<u8> = vec![];
        property.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_rw_property_bool() -> TResult<()> {
        let original = vec![
            0x13, 0x00, 0x00, 0x00, 0x48, 0x61, 0x76, 0x65, 0x53, 0x6B, 0x69, 0x6E, 0x73, 0x42,
            0x65, 0x65, 0x6E, 0x52, 0x65, 0x73, 0x65, 0x74, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x42,
            0x6F, 0x6F, 0x6C, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        ];
        let mut reader = Cursor::new(&original);
        let property = Property::read(&mut reader)?.unwrap();
        println!("{property:#?}");
        let mut reconstructed: Vec<u8> = vec![];
        property.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_rw_property_struct() -> TResult<()> {
        let original = vec![
            0x08, 0x00, 0x00, 0x00, 0x46, 0x6F, 0x72, 0x67, 0x69, 0x6E, 0x67, 0x00, 0x0F, 0x00,
            0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72,
            0x74, 0x79, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00,
            0x00, 0x46, 0x6F, 0x72, 0x67, 0x69, 0x6E, 0x67, 0x53, 0x61, 0x76, 0x65, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x58, 0x50, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49,
            0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x4E, 0x6F, 0x6E, 0x65, 0x00,
        ];
        let mut reader = Cursor::new(&original);
        let property = Property::read(&mut reader)?.unwrap();
        println!("{property:#?}");
        let mut reconstructed: Vec<u8> = vec![];
        property.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_rw_property_struct2() -> TResult<()> {
        let original = vec![
            0x07, 0x00, 0x00, 0x00, 0x44, 0x72, 0x69, 0x6E, 0x6B, 0x73, 0x00, 0x0F, 0x00, 0x00,
            0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74,
            0x79, 0x00, 0x52, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
            0x44, 0x72, 0x69, 0x6E, 0x6B, 0x53, 0x61, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
            0x00, 0x00, 0x00, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x44, 0x72, 0x69,
            0x6E, 0x6B, 0x73, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x65, 0x74, 0x50, 0x72, 0x6F,
            0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00,
            0x80, 0xC0, 0x60, 0x4B, 0x01, 0xA7, 0x22, 0x4F, 0x9D, 0xDD, 0x58, 0x9C, 0xAC, 0x18,
            0xF5, 0x23, 0x0A, 0x33, 0xAD, 0x36, 0xBB, 0xA5, 0x6E, 0x41, 0xB6, 0x2C, 0xC8, 0x8E,
            0xBB, 0xE4, 0x14, 0x13, 0xC0, 0x31, 0x45, 0x66, 0xAA, 0xDC, 0x7A, 0x43, 0x83, 0x22,
            0x26, 0xB0, 0x5B, 0xE0, 0x54, 0xCB, 0x85, 0x94, 0xDA, 0x82, 0xA8, 0xCC, 0x79, 0x41,
            0xB9, 0x96, 0xE7, 0x04, 0x71, 0xB1, 0x4D, 0xBA, 0x9E, 0x8C, 0x88, 0xA4, 0x30, 0xD8,
            0x3F, 0x45, 0xB3, 0x3B, 0xD1, 0x52, 0x57, 0x4A, 0xCB, 0xCA, 0x19, 0xB5, 0x58, 0x12,
            0xE5, 0xB4, 0x60, 0x42, 0xBE, 0xCD, 0xF0, 0x67, 0xB4, 0x33, 0xAF, 0xA3, 0x4E, 0x48,
            0x34, 0x2B, 0x70, 0x48, 0xC1, 0x4D, 0x92, 0xBD, 0x67, 0x1C, 0x1B, 0x8A, 0x76, 0x68,
            0x3F, 0x77, 0x73, 0x5B, 0x24, 0x29, 0x35, 0x4A, 0x88, 0x62, 0x18, 0xDE, 0xBA, 0x8C,
            0x79, 0x7D, 0x74, 0x51, 0xAD, 0x20, 0x57, 0x18, 0xFA, 0x45, 0xB0, 0x09, 0xF8, 0xF8,
            0xB1, 0x47, 0x37, 0x64, 0x88, 0x43, 0xC8, 0x85, 0x21, 0x73, 0x2D, 0x4B, 0x9D, 0x09,
            0x09, 0x26, 0xA0, 0x91, 0xA7, 0x9C, 0xA6, 0xAF, 0x43, 0xD6, 0xEE, 0x8B, 0x0D, 0x45,
            0xB3, 0xC4, 0xE3, 0x37, 0x46, 0x7B, 0xED, 0x5E, 0x5A, 0xA9, 0x4A, 0x29, 0xA9, 0x43,
            0xBD, 0x4C, 0xB8, 0xEE, 0x0D, 0x03, 0x42, 0x44, 0x29, 0x13, 0x8D, 0x21, 0xB5, 0x1B,
            0x4D, 0xC3, 0xA3, 0x4A, 0x8A, 0xA8, 0x19, 0x92, 0xBA, 0xB6, 0x94, 0x98, 0x13, 0x00,
            0x00, 0x00, 0x48, 0x61, 0x73, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x53,
            0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x42, 0x6F, 0x6F,
            0x6C, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65,
            0x00,
        ];
        let mut reader = Cursor::new(&original);
        let property = Property::read(&mut reader)?.unwrap();
        println!("{property:#?}");
        let mut reconstructed: Vec<u8> = vec![];
        property.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_rw_property_array() -> TResult<()> {
        let original = vec![
            0x0E, 0x00, 0x00, 0x00, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x49, 0x74,
            0x65, 0x6D, 0x73, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50,
            0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0xCB, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72,
            0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0E, 0x00,
            0x00, 0x00, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x49, 0x74, 0x65, 0x6D,
            0x73, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72,
            0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x05, 0x00, 0x00, 0x00, 0x47, 0x75, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76,
            0x3A, 0x96, 0xF0, 0x20, 0x19, 0x26, 0x46, 0xA6, 0x1D, 0x41, 0xF4, 0x98, 0xBE, 0x42,
            0x85, 0xB9, 0x5E, 0xDE, 0xC1, 0xBD, 0xDB, 0x1C, 0x47, 0x8E, 0x5D, 0xC5, 0x73, 0x22,
            0x10, 0x51, 0x34, 0xDD, 0xB5, 0xDA, 0x90, 0x86, 0xCD, 0x44, 0x42, 0xAF, 0x60, 0x06,
            0xDE, 0x2A, 0x43, 0x90, 0xA9, 0x28, 0xD2, 0x24, 0x72, 0xC4, 0x09, 0x22, 0x4E, 0xAF,
            0xFA, 0xCA, 0xC8, 0xB1, 0x37, 0x72, 0x87, 0x82, 0x08, 0x2A, 0xAB, 0x25, 0x31, 0x9F,
            0x43, 0xB4, 0x3A, 0x84, 0x58, 0xF5, 0x22, 0x8E, 0x8C, 0x4E, 0x96, 0xF4, 0x32, 0xD0,
            0x18, 0x23, 0x43, 0xA6, 0x2E, 0x81, 0xD8, 0x21, 0xA1, 0x48, 0x0F, 0x79, 0xE9, 0x1B,
            0xF1, 0x5A, 0xC1, 0x69, 0x4B, 0xA7, 0x98, 0x7C, 0x69, 0x69, 0x59, 0xC0, 0xD1, 0x97,
            0x36, 0xEE, 0x11, 0x0D, 0x4C, 0x87, 0x49, 0xA2, 0x24, 0xAF, 0x6F, 0x2D, 0xBA, 0x01,
            0x60,
        ];
        let mut reader = Cursor::new(&original);
        let property = Property::read(&mut reader)?.unwrap();
        println!("{property:#?}");
        let mut reconstructed: Vec<u8> = vec![];
        property.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_rw_property_str() -> TResult<()> {
        let original = vec![
            0x11, 0x00, 0x00, 0x00, 0x57, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x54, 0x75, 0x74,
            0x6F, 0x72, 0x69, 0x61, 0x6C, 0x73, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x41, 0x72, 0x72,
            0x61, 0x79, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x01, 0x07, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63,
            0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x0E, 0x00, 0x00,
            0x00, 0x11, 0x00, 0x00, 0x00, 0x57, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x54, 0x75,
            0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x73, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74,
            0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0xA8,
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x57, 0x61, 0x74,
            0x63, 0x68, 0x65, 0x64, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C,
            0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x50, 0x72,
            0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C,
            0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x44, 0x65, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x65,
            0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00, 0x00,
            0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74,
            0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00,
            0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x21, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74,
            0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x45, 0x71, 0x75,
            0x69, 0x70, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x54, 0x6F, 0x6F, 0x6C, 0x00, 0x06, 0x00,
            0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E,
            0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E,
            0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69,
            0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72,
            0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69,
            0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x45, 0x71, 0x75, 0x69, 0x70, 0x47,
            0x72, 0x65, 0x6E, 0x61, 0x64, 0x65, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75,
            0x6E, 0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D,
            0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D,
            0x65, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65,
            0x72, 0x74, 0x79, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B,
            0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69,
            0x6E, 0x74, 0x5F, 0x4C, 0x61, 0x73, 0x65, 0x72, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x65,
            0x72, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00,
            0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75,
            0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00,
            0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x27,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x54, 0x75,
            0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x45, 0x71,
            0x75, 0x69, 0x70, 0x53, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x61, 0x72, 0x79, 0x57, 0x65,
            0x61, 0x70, 0x6F, 0x6E, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74,
            0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72,
            0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00,
            0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00,
            0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74,
            0x79, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00,
            0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74,
            0x5F, 0x45, 0x71, 0x75, 0x69, 0x70, 0x54, 0x72, 0x61, 0x76, 0x65, 0x72, 0x73, 0x61,
            0x6C, 0x54, 0x6F, 0x6F, 0x6C, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E,
            0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65,
            0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00,
            0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65,
            0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72,
            0x74, 0x79, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00,
            0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E,
            0x74, 0x5F, 0x45, 0x67, 0x67, 0x4D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x54, 0x65,
            0x72, 0x72, 0x61, 0x69, 0x6E, 0x53, 0x63, 0x61, 0x6E, 0x6E, 0x65, 0x72, 0x00, 0x06,
            0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49,
            0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72,
            0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74,
            0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x19, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72,
            0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x46, 0x6C, 0x61, 0x72, 0x65,
            0x73, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00,
            0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75,
            0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00,
            0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x1C,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x54, 0x75,
            0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x4C, 0x6F,
            0x77, 0x4F, 0x6E, 0x41, 0x6D, 0x6D, 0x6F, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F,
            0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F,
            0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00,
            0x0D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61,
            0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x14, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48,
            0x69, 0x6E, 0x74, 0x5F, 0x4E, 0x69, 0x74, 0x72, 0x61, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50,
            0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E,
            0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C,
            0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x50, 0x72,
            0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C,
            0x5F, 0x54, 0x68, 0x72, 0x6F, 0x77, 0x43, 0x61, 0x72, 0x72, 0x69, 0x61, 0x62, 0x6C,
            0x65, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00,
            0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75,
            0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00,
            0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x28,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x54, 0x75,
            0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x42, 0x6F,
            0x73, 0x63, 0x6F, 0x46, 0x69, 0x72, 0x73, 0x74, 0x53, 0x6F, 0x6C, 0x6F, 0x4D, 0x69,
            0x73, 0x73, 0x69, 0x6F, 0x6E, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E,
            0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65,
            0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00,
            0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65,
            0x00, 0x0C, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72,
            0x74, 0x79, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
            0x00, 0x00, 0x54, 0x75, 0x74, 0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E,
            0x74, 0x5F, 0x42, 0x6F, 0x73, 0x63, 0x6F, 0x41, 0x62, 0x69, 0x6C, 0x69, 0x74, 0x79,
            0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x0C, 0x00, 0x00,
            0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74,
            0x6F, 0x72, 0x69, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00,
            0x53, 0x74, 0x72, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x1B, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x54, 0x75, 0x74,
            0x6F, 0x72, 0x69, 0x61, 0x6C, 0x5F, 0x48, 0x69, 0x6E, 0x74, 0x5F, 0x52, 0x65, 0x73,
            0x75, 0x70, 0x70, 0x6C, 0x79, 0x00, 0x06, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E,
            0x74, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x49, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65,
            0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00,
        ];
        let mut reader = Cursor::new(&original);
        let property = Property::read(&mut reader)?.unwrap();
        println!("{property:#?}");
        let mut reconstructed: Vec<u8> = vec![];
        property.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }

    #[test]
    fn test_rw_header() -> TResult<()> {
        let original = vec![
            0x47, 0x56, 0x41, 0x53, 0x02, 0x00, 0x00, 0x00, 0x0A, 0x02, 0x00, 0x00, 0x04, 0x00,
            0x1B, 0x00, 0x02, 0x00, 0xFA, 0x14, 0x01, 0x80, 0x05, 0x00, 0x00, 0x00, 0x6D, 0x61,
            0x69, 0x6E, 0x00, 0x03, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x4E, 0x7C, 0xE7,
            0x82, 0xA5, 0x43, 0x23, 0x33, 0xC5, 0x13, 0x6B, 0xB4, 0xF3, 0x0D, 0x31, 0x97, 0x00,
            0x00, 0x00, 0x00, 0xFA, 0x7A, 0xF5, 0xFC, 0x83, 0x42, 0x76, 0x50, 0x58, 0xE6, 0xA9,
            0xB9, 0x32, 0x2D, 0xA0, 0xFF, 0x44, 0x00, 0x00, 0x00, 0xF3, 0x7A, 0xBB, 0x24, 0x83,
            0x4F, 0x46, 0x56, 0xC2, 0x2D, 0x2F, 0x1F, 0xFF, 0x96, 0xAD, 0x49, 0x05, 0x00, 0x00,
            0x00, 0x12, 0xE4, 0x26, 0xFB, 0x4D, 0x4B, 0x15, 0x1F, 0x0A, 0x55, 0x72, 0x93, 0x70,
            0x2F, 0x1D, 0x96, 0x03, 0x00, 0x00, 0x00, 0x22, 0xD5, 0x54, 0x9C, 0xBE, 0x4F, 0x26,
            0xA8, 0x46, 0x07, 0x21, 0x94, 0xD0, 0x82, 0xB4, 0x61, 0x2B, 0x00, 0x00, 0x00, 0xE4,
            0x32, 0xD8, 0xB0, 0x0D, 0x4F, 0x89, 0x1F, 0xB7, 0x7E, 0xCF, 0xAC, 0xA2, 0x4A, 0xFD,
            0x36, 0x0A, 0x00, 0x00, 0x00, 0x28, 0x43, 0xC6, 0xE1, 0x53, 0x4D, 0x2C, 0xA2, 0x86,
            0x8E, 0x6C, 0xA3, 0x8C, 0xBD, 0x17, 0x64, 0x00, 0x00, 0x00, 0x00, 0x3C, 0xC1, 0x5E,
            0x37, 0xFB, 0x48, 0xE4, 0x06, 0xF0, 0x84, 0x00, 0xB5, 0x7E, 0x71, 0x2A, 0x26, 0x04,
            0x00, 0x00, 0x00, 0xED, 0x68, 0xB0, 0xE4, 0xE9, 0x42, 0x94, 0xF4, 0x0B, 0xDA, 0x31,
            0xA2, 0x41, 0xBB, 0x46, 0x2E, 0x28, 0x00, 0x00, 0x00, 0x3F, 0x74, 0xFC, 0xCF, 0x80,
            0x44, 0xB0, 0x43, 0xDF, 0x14, 0x91, 0x93, 0x73, 0x20, 0x1D, 0x17, 0x25, 0x00, 0x00,
            0x00, 0xB5, 0x49, 0x2B, 0xB0, 0xE9, 0x44, 0x20, 0xBB, 0xB7, 0x32, 0x04, 0xA3, 0x60,
            0x03, 0xE4, 0x52, 0x03, 0x00, 0x00, 0x00, 0x5C, 0x10, 0xE4, 0xA4, 0xB5, 0x49, 0xA1,
            0x59, 0xC4, 0x40, 0xC5, 0xA7, 0xEE, 0xDF, 0x7E, 0x54, 0x00, 0x00, 0x00, 0x00, 0xC9,
            0x31, 0xC8, 0x39, 0xDC, 0x47, 0xE6, 0x5A, 0x17, 0x9C, 0x44, 0x9A, 0x7C, 0x8E, 0x1C,
            0x3E, 0x00, 0x00, 0x00, 0x00, 0x33, 0x1B, 0xF0, 0x78, 0x98, 0x4F, 0xEA, 0xEB, 0xEA,
            0x84, 0xB4, 0xB9, 0xA2, 0x5A, 0xB9, 0xCC, 0x0E, 0x00, 0x00, 0x00, 0x0F, 0x38, 0x31,
            0x66, 0xE0, 0x43, 0x4D, 0x2D, 0x27, 0xCF, 0x09, 0x80, 0x5A, 0xA9, 0x56, 0x69, 0x00,
            0x00, 0x00, 0x00, 0x9F, 0x8B, 0xF8, 0x12, 0xFC, 0x4A, 0x75, 0x88, 0x0C, 0xD9, 0x7C,
            0xA6, 0x29, 0xBD, 0x3A, 0x38, 0x2D, 0x00, 0x00, 0x00, 0x4C, 0xE7, 0x5A, 0x7B, 0x10,
            0x4C, 0x70, 0xD2, 0x98, 0x57, 0x58, 0xA9, 0x5A, 0x2A, 0x21, 0x0B, 0x0D, 0x00, 0x00,
            0x00, 0x18, 0x69, 0x29, 0xD7, 0xDD, 0x4B, 0xD6, 0x1D, 0xA8, 0x64, 0xE2, 0x9D, 0x84,
            0x38, 0xC1, 0x3C, 0x03, 0x00, 0x00, 0x00, 0x78, 0x52, 0xA1, 0xC2, 0xFE, 0x4A, 0xE7,
            0xBF, 0xFF, 0x90, 0x17, 0x6C, 0x55, 0xF7, 0x1D, 0x53, 0x01, 0x00, 0x00, 0x00, 0xD4,
            0xA3, 0xAC, 0x6E, 0xC1, 0x4C, 0xEC, 0x40, 0xED, 0x8B, 0x86, 0xB7, 0xC5, 0x8F, 0x42,
            0x09, 0x03, 0x00, 0x00, 0x00, 0xDD, 0x75, 0xE5, 0x29, 0x27, 0x46, 0xA3, 0xE0, 0x76,
            0xD2, 0x10, 0x9D, 0xEA, 0xDC, 0x2C, 0x23, 0x11, 0x00, 0x00, 0x00, 0x5D, 0xA6, 0x43,
            0xAF, 0x47, 0x49, 0xD3, 0x7F, 0x8E, 0x3E, 0x73, 0x98, 0x05, 0xBB, 0xC1, 0xD9, 0x0F,
            0x00, 0x00, 0x00, 0xEC, 0x6C, 0x26, 0x6B, 0x8F, 0x4B, 0xC7, 0x1E, 0xD9, 0xE4, 0x0B,
            0xA3, 0x07, 0xFC, 0x42, 0x09, 0x01, 0x00, 0x00, 0x00, 0x61, 0x3D, 0xF7, 0x0D, 0xEA,
            0x47, 0x3F, 0xA2, 0xE9, 0x89, 0x27, 0xB7, 0x9A, 0x49, 0x41, 0x0C, 0x01, 0x00, 0x00,
            0x00, 0x86, 0x18, 0x1D, 0x60, 0x84, 0x4F, 0x64, 0xAC, 0xDE, 0xD3, 0x16, 0xAA, 0xD6,
            0xC7, 0xEA, 0x0D, 0x2F, 0x00, 0x00, 0x00, 0x68, 0x63, 0x08, 0xE7, 0x58, 0x4C, 0x23,
            0x6B, 0x70, 0x1B, 0x39, 0x84, 0x91, 0x5E, 0x26, 0x16, 0x01, 0x00, 0x00, 0x00, 0xD6,
            0xBC, 0xFF, 0x9D, 0x58, 0x01, 0x4F, 0x49, 0x82, 0x12, 0x21, 0xE2, 0x88, 0xA8, 0x92,
            0x3C, 0x0A, 0x00, 0x00, 0x00, 0xAC, 0xD0, 0xAE, 0xF2, 0x6F, 0x41, 0xFE, 0x9A, 0x7F,
            0xAA, 0x64, 0x86, 0xFC, 0xD6, 0x26, 0xFA, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x1F, 0x4F,
            0x17, 0xA5, 0x45, 0xC6, 0xB4, 0xE8, 0x2E, 0x3F, 0xB1, 0x7D, 0x91, 0xFB, 0xD0, 0x0A,
            0x00, 0x00, 0x00, 0x83, 0x4A, 0xF9, 0x35, 0x6C, 0x40, 0x58, 0xE2, 0xF5, 0x09, 0x18,
            0xA3, 0x7C, 0x24, 0x10, 0x96, 0x29, 0x00, 0x00, 0x00, 0x6E, 0xC1, 0x8F, 0xB6, 0xE2,
            0x42, 0x1B, 0x8B, 0x5C, 0x21, 0x53, 0xB4, 0xFE, 0x44, 0x88, 0x05, 0x01, 0x00, 0x00,
            0x00, 0x06, 0x85, 0xE1, 0xB2, 0xC2, 0xCF, 0x73, 0x42, 0xBB, 0xF4, 0x4E, 0xA5, 0x07,
            0xBA, 0x8B, 0x75, 0x01, 0x00, 0x00, 0x00, 0x36, 0x89, 0xF5, 0x64, 0xBA, 0x42, 0x1B,
            0xFD, 0x89, 0x72, 0x96, 0xBA, 0x4E, 0xFA, 0xD0, 0xD5, 0x01, 0x00, 0x00, 0x00, 0x27,
            0xD8, 0x0E, 0x6F, 0x95, 0x48, 0x09, 0xA6, 0x8D, 0x99, 0x91, 0x9C, 0xA4, 0x0E, 0x18,
            0x90, 0x02, 0x00, 0x00, 0x00, 0xE7, 0x9E, 0x7F, 0x71, 0x3A, 0x49, 0xB0, 0xE9, 0x32,
            0x91, 0xB3, 0x88, 0x07, 0x81, 0x38, 0x1B, 0x08, 0x00, 0x00, 0x00, 0x50, 0x32, 0x68,
            0x54, 0xAF, 0x48, 0x99, 0x80, 0x96, 0x98, 0xC8, 0x8B, 0xB7, 0xF9, 0xAD, 0xFB, 0x00,
            0x00, 0x00, 0x00, 0x19, 0x4D, 0x0C, 0x43, 0x70, 0x49, 0x54, 0x71, 0x69, 0x9B, 0x69,
            0x87, 0xE5, 0xB0, 0x90, 0xDF, 0x0F, 0x00, 0x00, 0x00, 0xBD, 0x32, 0xFE, 0xAA, 0x14,
            0x4C, 0x95, 0x53, 0x25, 0x5E, 0x6A, 0xB6, 0xDD, 0xD1, 0x32, 0x10, 0x01, 0x00, 0x00,
            0x00, 0x8E, 0xE1, 0xAF, 0x23, 0x58, 0x4E, 0xE1, 0x4C, 0x52, 0xC2, 0x61, 0x8D, 0xB7,
            0xBE, 0x53, 0xB9, 0x0B, 0x00, 0x00, 0x00, 0xEA, 0xB7, 0x62, 0xA4, 0x3A, 0x4E, 0x99,
            0xF4, 0x1F, 0xEC, 0xC1, 0x99, 0xB2, 0xE1, 0x24, 0x82, 0x04, 0x00, 0x00, 0x00, 0xBD,
            0xFD, 0xB5, 0x2E, 0x10, 0x4D, 0xAC, 0x01, 0x8F, 0xF3, 0x36, 0x81, 0xDA, 0xA5, 0x93,
            0x33, 0x05, 0x00, 0x00, 0x00, 0x4F, 0x35, 0x9D, 0x50, 0x2F, 0x49, 0xE6, 0xF6, 0xB2,
            0x85, 0x49, 0xA7, 0x1C, 0x63, 0x3C, 0x07, 0x00, 0x00, 0x00, 0x00, 0x40, 0xEB, 0x56,
            0x4A, 0xDC, 0x11, 0xF5, 0x10, 0x7E, 0x34, 0xD3, 0x92, 0xE7, 0x6A, 0xC9, 0xB2, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x4A, 0x8A, 0xD7, 0x97, 0x46, 0x58, 0xE8, 0xB5, 0x19, 0xA8,
            0xBA, 0xB4, 0x46, 0x7D, 0x48, 0x12, 0x00, 0x00, 0x00, 0x86, 0xF8, 0x79, 0x55, 0x1F,
            0x4C, 0x3A, 0x93, 0x7B, 0x08, 0xBA, 0x83, 0x2F, 0xB9, 0x61, 0x63, 0x02, 0x00, 0x00,
            0x00, 0x52, 0xBE, 0x2F, 0x61, 0x0B, 0x40, 0x53, 0xDA, 0x91, 0x4F, 0x0D, 0x91, 0x7C,
            0x85, 0xB1, 0x9F, 0x01, 0x00, 0x00, 0x00, 0x36, 0x7A, 0x23, 0xA4, 0xC9, 0x41, 0xEA,
            0xCA, 0xF8, 0x18, 0xA2, 0x8F, 0xF3, 0x1B, 0x68, 0x58, 0x04, 0x00, 0x00, 0x00, 0x75,
            0x3F, 0x4E, 0x80, 0x49, 0x4B, 0x88, 0x70, 0x06, 0x8C, 0xD6, 0xA4, 0xDC, 0xB6, 0x7E,
            0x3C, 0x05, 0x00, 0x00, 0x00, 0xF2, 0x0A, 0x68, 0xFB, 0xA3, 0x4B, 0xEF, 0x59, 0xB5,
            0x19, 0xA8, 0xBA, 0x3D, 0x44, 0xC8, 0x73, 0x02, 0x00, 0x00, 0x00, 0x0E, 0xB7, 0x50,
            0x99, 0x17, 0x4E, 0x1A, 0xB4, 0x0D, 0xFA, 0xCC, 0xBB, 0xD6, 0x7F, 0x81, 0x57, 0x01,
            0x00, 0x00, 0x00,
        ];
        let mut reader = Cursor::new(&original);
        let obj = Header::read(&mut reader)?;
        let mut reconstructed: Vec<u8> = vec![];
        obj.write(&mut reconstructed)?;
        assert_eq!(original, reconstructed);
        Ok(())
    }
}
